<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VuePress</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/docs/assets/css/0.styles.5037e10c.css" as="style"><link rel="preload" href="/docs/assets/js/app.01c57ae1.js" as="script"><link rel="preload" href="/docs/assets/js/2.6ead0304.js" as="script"><link rel="preload" href="/docs/assets/js/12.b0234b2e.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.da0c92a5.js"><link rel="prefetch" href="/docs/assets/js/11.78ba5273.js"><link rel="prefetch" href="/docs/assets/js/13.852a65b6.js"><link rel="prefetch" href="/docs/assets/js/14.d65ae1a0.js"><link rel="prefetch" href="/docs/assets/js/15.9f39cd23.js"><link rel="prefetch" href="/docs/assets/js/16.d20db39b.js"><link rel="prefetch" href="/docs/assets/js/3.4617ac6d.js"><link rel="prefetch" href="/docs/assets/js/4.5cc5de6c.js"><link rel="prefetch" href="/docs/assets/js/5.c0a17e28.js"><link rel="prefetch" href="/docs/assets/js/6.00b48d75.js"><link rel="prefetch" href="/docs/assets/js/7.bfe91f85.js"><link rel="prefetch" href="/docs/assets/js/8.cfd2dada.js"><link rel="prefetch" href="/docs/assets/js/9.2764f422.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.5037e10c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><img src="/docs/img/head.jpg" alt="" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Support
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language" class="dropdown-title"><span class="title">Language</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language" class="mobile-dropdown-title"><span class="title">Language</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/language/chinese/" class="nav-link">
  Chinese
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Support
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language" class="dropdown-title"><span class="title">Language</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language" class="mobile-dropdown-title"><span class="title">Language</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/language/chinese/" class="nav-link">
  Chinese
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/docs/Algorithm/" class="sidebar-heading clickable router-link-active open"><span>Algorithm</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/Algorithm/1~20.html" class="sidebar-link">剑指Offer-1~20</a></li><li><a href="/docs/Algorithm/21~40.html" class="sidebar-link">剑指Offer-21~40</a></li><li><a href="/docs/Algorithm/41~60.html" class="sidebar-link">剑指Offer-41~60</a></li><li><a href="/docs/Algorithm/61~67.html" class="sidebar-link">剑指Offer-61~67</a></li><li><a href="/docs/Algorithm/Sort.html" aria-current="page" class="active sidebar-link">排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/Algorithm/Sort.html#直接插入排序" class="sidebar-link">直接插入排序</a></li><li class="sidebar-sub-header"><a href="/docs/Algorithm/Sort.html#折半插入排序" class="sidebar-link">折半插入排序</a></li><li class="sidebar-sub-header"><a href="/docs/Algorithm/Sort.html#希尔排序" class="sidebar-link">希尔排序</a></li><li class="sidebar-sub-header"><a href="/docs/Algorithm/Sort.html#冒泡排序" class="sidebar-link">冒泡排序</a></li><li class="sidebar-sub-header"><a href="/docs/Algorithm/Sort.html#快速排序" class="sidebar-link">快速排序</a></li><li class="sidebar-sub-header"><a href="/docs/Algorithm/Sort.html#简单选择排序" class="sidebar-link">简单选择排序</a></li><li class="sidebar-sub-header"><a href="/docs/Algorithm/Sort.html#树型选择排序" class="sidebar-link">树型选择排序</a></li><li class="sidebar-sub-header"><a href="/docs/Algorithm/Sort.html#堆排序" class="sidebar-link">堆排序</a></li><li class="sidebar-sub-header"><a href="/docs/Algorithm/Sort.html#测试代码" class="sidebar-link">测试代码</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/docs/DataStruct/" class="sidebar-heading clickable"><span>DataStruct</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/DataStruct/BinaryTreeSearch.html" class="sidebar-link">单链表插入删除</a></li><li><a href="/docs/DataStruct/SingleList.html" class="sidebar-link">单链表插入删除</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>[TOC]</p> <h1 id="插入排序"><a href="#插入排序" class="header-anchor">#</a> 插入排序</h1> <h2 id="直接插入排序"><a href="#直接插入排序" class="header-anchor">#</a> 直接插入排序</h2> <ul><li><p><strong>思想</strong></p> <p>每次将一个待排序的元素插入到前面已经有序的子序列中。</p></li> <li><p><strong>算法</strong></p> <p>第一个元素已经形成有序子序列，从第二个元素开始：</p> <ol><li>在有序子序列中查找合适的位置<code>i</code>，同时将经过的元素后移一位；</li> <li>将当前元素写入位置<code>i</code>;</li></ol></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>template&lt;typename T&gt;
void insertSort(T &amp;data) {
	//依次将元素插入其到前面的有序序列中
	for (int i = 1; i &lt; data.size(); i++) {
		int curr = data.at(i);//记录当前元素
		int j = i - 1;
		//当前元素依次与前面元素比较，并将大于当前元素的元素后移一位
		for (; j &gt;= 0 &amp;&amp; curr &lt; data.at(j); j--)
			data.at(j + 1) = data.at(j);//后移			
		data.at(j + 1) = curr;//空位填入当前元素
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li><p><strong>性能</strong></p> <ul><li>时间复杂度：平均O(n^2^)，最优O(n)</li> <li>空间复杂度：O(1)</li> <li>稳定性：稳定</li> <li>适用于：原序列基本有序，规模较小，这样移动次数少</li></ul></li></ul> <h2 id="折半插入排序"><a href="#折半插入排序" class="header-anchor">#</a> 折半插入排序</h2> <ul><li><p><strong>思想</strong></p> <p>类似于直接插入排序，不过将查找与移动操作分离，查找使用折半查找。</p></li> <li><p><strong>算法</strong></p> <p>第一个元素已经形成有序子序列，从第二个元素开始：</p> <ol><li><p>在有序子序列中折半查找合适的位置<code>i</code>；</p></li> <li><p>将<code>i</code>开始往后的元素后移一位；</p></li> <li><p>将当前元素写入位置<code>i</code>;</p></li></ol></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>template&lt;typename T&gt;
void binaryInsertSort(T &amp;data) {
	for (int i = 1; i &lt; data.size(); i++) {
		int curr = data.at(i);
         //折半查找
		int low = 0, high = i - 1;		
		while (low &lt;= high)
		{
			int mid = (low + high) / 2;
			if (data.at(mid) &lt; curr) low = mid + 1;
			else high = mid - 1;
		}
		//high  * curr   mid
		for (int j = i; j &gt; high + 1; j--) {
			data.at(j) = data.at(j - 1);
		}
		data.at(high + 1) = curr;
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></li> <li><p><strong>分析</strong></p> <p>结论：折半查找结束总有位置关系<code>high</code> &lt;= <code>KEY</code> &lt;=  <code>low</code>，且<code>high + 1 = low</code>。</p> <ul><li><p><strong>情况1：</strong></p> <p><img src="D:%5CNotebook%5Cimg%5C1585582199177.png" alt="1585582199177"></p> <p>KEY始终小于mid值，high不断减一，直到high小于low。</p> <p>最终<code>high = low - 1 = -1</code>。low是第一个比KEY大的。<code>high(null)</code> <code>KEY</code>  &lt;  <code>low</code></p></li> <li><p><strong>情况2：</strong></p> <p><img src="D:%5CNotebook%5Cimg%5C1585582540166.png" alt="1585582540166"></p> <p>KEY等于low值，mid一开始位于low、high之间，high不断减一，直到high= low时，high仍会减一次一。</p> <p>最终<code>high = low - 1 = -1</code>。low值等于KEY。<code>high(null)</code> <code>KEY</code>  =  <code>low</code></p></li> <li><p><strong>情况3</strong></p> <p><img src="D:%5CNotebook%5Cimg%5C1585583278406.png" alt="1585583278406"></p> <p>KEY等于high值，mid一开始位于low、high之间，low不断加一，直到low = high时，high仍会减一次一。</p> <p>最终<code>high = low - 1</code>。high值等于KEY。<code>high</code> &lt; <code>KEY</code>  =  <code>low</code></p></li> <li><p><strong>情况4</strong></p> <p><img src="D:%5CNotebook%5Cimg%5C1585583575580.png" alt="1585583575580"></p> <p>KEY始终大于high值，low不断加一，直到low大于high。</p> <p>最终<code>low = high + 1</code>。high是第一个比KEY小的。<code>high</code> &lt; <code>KEY</code> <code>low(null)</code></p></li> <li><p><strong>情况5：</strong></p> <p><img src="D:%5CNotebook%5Cimg%5C1585582901145.png" alt="1585582901145"></p> <p>当mid值始终不等于KEY时，可能low加一，可能high减一，但总会有low或high跳过KEY，此时转变为情况1或情况4；</p> <p>当某次mid值等于KEY时，high仍会减一，转变为情况4；</p> <p>==最终KEY值在high、low之间。==</p></li></ul></li> <li><p><strong>性能</strong></p> <p>时空复杂度与直接插入排序相近，因为只减少了比较操作，移动操作未变。</p> <ul><li>稳定性：稳定</li></ul></li></ul> <h2 id="希尔排序"><a href="#希尔排序" class="header-anchor">#</a> 希尔排序</h2> <ul><li><p><strong>思想</strong></p> <p>针对直接插入排序适用于基本有序序列的特点，创造这个条件，然后使用直插。</p></li> <li><p><strong>算法</strong></p> <ol><li>取增量di = d1将记录分成di组，同组内进行直接插入排序；</li> <li>取增量di = d2（d2&lt;d1），重复1；</li> <li>直到取增量di = 1，对整个序列进行一次直接插入排序；</li></ol></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>template&lt;typename T&gt;
void shellSort(T &amp;data) {
	int di = data.size() / 2;
	for (; di &gt;= 1; di /= 2)
		for (int i = di; i &lt; data.size(); i++) {//交替对每组进行直接插入排序
			int curr = data.at(i);
			int j = i - di;
			for (; j &gt;= 0 &amp;&amp; curr &lt; data.at(j); j -= di)
				data.at(j + di) = data.at(j);
			data.at(j + di) = curr;
		}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li><p><strong>分析</strong></p> <p>一般取d1 = size/2，d~i+1~ = d~i~/2。</p></li> <li><p><strong>性能</strong></p> <ul><li>时间复杂度：O(n^2^)</li> <li>空间复杂度：O(1)</li> <li>稳定性：不稳定（跳跃时相同元素分到不同组）</li> <li>适用于：原序列无序，规模较大（相对直插）</li></ul></li></ul> <hr> <h1 id="交换排序"><a href="#交换排序" class="header-anchor">#</a> 交换排序</h1> <h2 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h2> <ul><li><p><strong>思想</strong></p> <p>从后往前将较小的元素交换到序列首位。</p></li> <li><p><strong>算法</strong></p> <ol><li>从序列尾开始将最小的元素通过交换移动到当前序列首位；</li> <li>去除首位元素重复1；</li></ol></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>template&lt;typename T&gt;
void BubbleSort(T &amp;data) {
	for (int i = 0; i &lt; (int)data.size() - 1; i++) {//size-1次
		bool finished = true;//表示这趟冒泡是否因未发生交换从而可以直接结束
		for (int j = (int)data.size() - 1; j &gt; i; j--)//从队尾到i 
			if (data.at(j) &lt; data.at(j - 1)) {
				swap(data.at(j), data.at(j - 1));
				finished = false;
			}
		if (finished) return;
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li><p><strong>性能</strong></p> <ul><li>时间复杂度：平均O(n^2^)，最优O(n)，最差O(n^2^)</li> <li>空间复杂度：O(1)</li> <li>稳定性：稳定</li> <li>适用于：规模较大，无序时不宜采用</li></ul></li></ul> <h2 id="快速排序"><a href="#快速排序" class="header-anchor">#</a> 快速排序</h2> <ul><li><p><strong>思想</strong></p> <p>每次趟排序选取序列第一个元素作为基准，将所有小于该元素的元素移动到其左边，大于该元素的元素移动到其右边。对左边，右边进行递归。</p></li> <li><p><strong>算法</strong></p> <ol><li><p>选取<code>base</code>为序列首元素，左索引<code>l</code>指向序列首，右索引<code>r</code>指向序列尾；</p></li> <li><p>根据索引遍历所有元素，小于<code>base</code>的移动到左边，大于<code>base</code>的移动到右边：</p> <p><code>r</code>递减过程中，当碰到小于<code>base</code>的元素，将其与<code>l</code>位置元素交换；</p> <p><code>l</code>递增过程中，当碰到大于<code>base</code>的元素，将其与<code>r</code>位置元素交换；</p></li> <li><p>对<code>base</code>左右的序列递归；</p></li></ol></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>template&lt;typename T&gt;
void quickSort(T &amp;data, int start, int end) {
	if (start &gt;= end) return;
	int base = data.at(start);
	int l = start, r = end;
	while (l &lt; r) {
		while (l &lt; r &amp;&amp; data.at(r) &gt;= base) r--;
		data.at(l) = data.at(r);
		while (l &lt; r &amp;&amp; data.at(l) &lt;= base) l++;
		data.at(r) = data.at(l);
	}
	//结束时 l 等于 r
	data.at(l) = base;
	quickSort(data, start, l - 1);
	quickSort(data, l + 1, end);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></li> <li><p><strong>分析</strong></p> <p><img src="D:%5CNotebook%5Cimg%5C1585631771875.png" alt="1585631771875"></p></li> <li><p><strong>性能</strong></p> <ul><li>时间复杂度：平均O(nlog~2~n)，最差O(n^2^)，最优O(nlog~2~n)</li> <li>空间复杂度：平均O(log~2~n)，最差O(n)</li> <li>稳定性：不稳定</li> <li>适用于：规模较大，无序</li></ul></li></ul> <h1 id="选择排序"><a href="#选择排序" class="header-anchor">#</a> 选择排序</h1> <h2 id="简单选择排序"><a href="#简单选择排序" class="header-anchor">#</a> 简单选择排序</h2> <ul><li><p><strong>思想</strong></p> <p>第<code>i</code>趟排序，从第<code>i</code>个元素开始到序列尾中找到最小元素，替换第<code>i</code>个元素。</p></li> <li><p><strong>算法</strong></p> <p>遍历每个元素</p> <ol><li>从当前元素开始查找最小元素；</li> <li>替换当前元素</li></ol></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>template&lt;typename T&gt;
void selectSort(T &amp;data) {	
	for (int i = 0; i &lt; (int)data.size() - 1; i++) {
		int minLoc = i;
		for (int j = i + 1; j &lt; data.size(); j++)
			if (data.at(j) &lt; data.at(minLoc)) minLoc = j;
		if (minLoc != i) swap(data.at(i), data.at(minLoc));
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p><strong>性能</strong></p> <ul><li>时间复杂度：O(n^2^)</li> <li>空间复杂度：O(1)</li> <li>稳定性：不稳定</li></ul></li></ul> <h2 id="树型选择排序"><a href="#树型选择排序" class="header-anchor">#</a> 树型选择排序</h2> <ul><li><p><strong>思想</strong></p> <p>树形选择排序过程可用一棵有n个叶子结点的完全二叉树表示。</p> <p>找出最小：首先对n个记录的关键字进行两两比较，然后在n/2个较小者之间再进行两两比较，如此重复，直至选出最小的记录为止。</p> <p>找出次小：将最底层最小值叶子节点替换为∞，从该叶子结点开始向上与其左或右兄弟比较，修改从叶子结点到根的路径上各结点的值，则根结点的数值即为最小值。</p></li> <li><p><strong>性能</strong></p> <ul><li>时间复杂度：由于含有n个子结点的完全二叉树的深度为log~2~n+1，则在树形选择排序中，除了最小值之外，每选择一个次小值仅需要进行log~2~n次比较，因此，它的时间复杂度为O(nlog~2~n)</li> <li>空间复杂度：O(n)</li></ul></li></ul> <h2 id="堆排序"><a href="#堆排序" class="header-anchor">#</a> 堆排序</h2> <ul><li><p><strong>思想</strong></p> <p>树型选择排序方法有辅助存储空间较多、“最大值”进行多余比较等缺点，由此提出了堆排序。</p> <p>堆是一个近似完全二叉树的结构，并同时满足堆积的性质：<strong>子结点的值总是小于（或者大于）它的父节点。</strong></p> <p>完全二叉树使用顺序结构存储。</p> <p>大根堆：根结点值大于左右子节点值。左右子树也是大根堆。</p> <p>小根堆：根结点值小于左右子节点值。左右子 树也是小根堆。</p></li> <li><p><strong>算法（大根堆）</strong></p> <p>堆排序步骤</p> <ol><li>建初堆：将序列s[0,n~1]调整为大根堆；</li> <li>交换s[0]与s[n-1]，即将堆顶元素（最大/最小）与序列尾元素交换</li> <li>调整堆：从堆顶开始调整堆，使交换到堆顶的元素下降到合适的位置；</li> <li>令s = s[0,n-2]，重复1、2、3；</li></ol></li> <li><p><strong>实现</strong></p> <p><strong>调整堆</strong></p> <ol><li><p>向下调整堆：</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>/*
除去序列首元素已经满足堆的条件，将序列首元素下调到合适的位置
调整以start为根结点的堆，令最大值到达堆顶
end表示序列尾的索引
*/
template&lt;typename T&gt;
void adjustDown(T &amp;data, int start, int end) {
	if (data.size() == 0) return;
	int copy = data.at(start);
	for (int i = 2 * start + 1; i &lt;= end; i = 2 * i + 1) {
		//令i指向左右子节点中较大者
		if (i &lt; end &amp;&amp; data.at(i) &lt; data.at(i + 1)) i++;
		if (copy &gt;= data.at(i))//根结点不小于较大者，不需要调整
			break;
		else {
			data.at(start) = data.at(i);//令根结点等于子节点
			start = i;//调整以该子节点为根结点的堆
		}
	}
	data.at(start) = copy;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div></li> <li><p>向上调整堆：</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>/*
除去序列尾元素已经满足堆的条件，将序列尾元素上调到合适的位置
*/
template&lt;typename T&gt;
void adjustUp(T &amp;data) {
	if (data.size() &lt;= 1) return;
	int k = (int)data.size() - 1;//k指向序列最后一个元素
	int copy = data.at(k);//备份插入的元素
	int i = (k - 1) / 2;//i指向新插入元素的父元素
	while (data.at(i) &lt; copy) {//父元素插入的元素
		data.at(k) = data.at(i);//当前元素位置替换为父元素
		k = i;//当前元素变为父元素
		if (i &lt;= 0) break;
		i = (k - 1) / 2;
	}
	data.at(k) = copy;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li></ol> <p><strong>建初堆</strong></p> <p>由于存在两种调整堆的方式，因此也有两种建初堆的方式</p> <ol><li><p>对整个非堆序列从最后一个非叶节点开始向下调整堆</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>/*使所有根结点值都大于其左右子节点值*/
template&lt;typename T&gt;
void buildMaxHeap1(T &amp;data) {
	if (data.size() == 0) return;
	//从完全二叉树最后一个非叶节点（索引为n/2 - 1）开始向前依次向下调整
	for (int i = (data.size() / 2) - 1; i &gt;= 0; i--) {
		adjustDown(data, i, (int)data.size() - 1);
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>通过向堆序列插入元素，向上调整堆</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>/*向堆序列插入元素*/
template&lt;typename T&gt;
void heapInsert(T &amp;data, int val) {
	data.push_back(val);
	adjustUp(data);
}

template&lt;typename T&gt;
void buildMaxHeap2(T &amp;data) {
	if (data.size() == 0) return;
	T dataCopy = { data.at(0) };
	for (int i = 1; i &lt; data.size(); i++) {
		heapInsert(dataCopy, data.at(i));
	}
	data.assign(dataCopy.begin(), dataCopy.end());
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></li></ol> <p><strong>排序</strong></p> <p>使用大根堆进行堆排序，得到非递减序列</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>template&lt;typename T&gt;
void heapSort(T &amp;data) {
    if (data.size() == 0) return;
    buildMaxHeap2(data);
    for (int i = (int)data.size() - 1; i &gt; 0; i--) {
        swap(data.at(0), data.at(i));
        adjustDown(data, 0, i - 1);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p><strong>性能</strong></p> <ul><li>时间复杂度：O(nlog~2~n)</li> <li>空间复杂度：O(1)</li> <li>稳定性：不稳定</li></ul></li></ul> <h1 id="归并排序"><a href="#归并排序" class="header-anchor">#</a> 归并排序</h1> <ul><li><p><strong>思想</strong></p> <p>归并指将多个有序序列合并为一个新的有序序列，排序开始时，认为有n个长度为1的有序序列。</p></li> <li><p><strong>算法</strong></p> <p>采用分治法，通过递归减半序列长度，对左右两边进行合并操作</p></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>template&lt;typename T&gt;
void merge(T &amp;v, int low, int mid, int high) {
	T copy(v.begin() + low, v.begin() + high + 1);//辅助空间
	int leftNum = mid - low + 1;
	int allNum = high - low + 1;
	int i = 0, j = leftNum, k = low;
	while (i &lt; leftNum &amp;&amp; j &lt; allNum) 
		if (copy.at(i) &lt;= copy.at(j)) 
			v.at(k++) = copy.at(i++);		
		else 
			v.at(k++) = copy.at(j++);			
	while (i &lt; leftNum) v.at(k++) = copy.at(i++);
	while (j &lt; allNum) v.at(k++) = copy.at(j++);
}
template&lt;typename T&gt;
void mergeSort(T &amp;data, int low, int high) {
	if (low &lt; high) {
		int mid = (low + high) / 2;
		mergeSort(data, low, mid);
		mergeSort(data, mid + 1, high);
		merge(data, low, mid, high);
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div></li> <li><p><strong>性能</strong></p> <ul><li>时间复杂度：O(nlog~2~n)</li> <li>空间复杂度：O(n)</li> <li>稳定性：稳定</li></ul></li></ul> <h1 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h1> <p>==注意==</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>vector&lt;int&gt;.size()返回值是unsigned int,如果为0要减一减一要强制转换为int
cout &lt;&lt; typeid(d1.size()).name();//unsigned int
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>稳定性：大小相同的元素，排序前后其相对位置不变，则排序是稳定的。</p> <p>① 稳定性排序：冒泡排序，插入排序、归并排序、基数排序</p> <p>② 不稳定性排序：选择排序、快速排序、希尔排序、堆排序</p> <h2 id="测试代码"><a href="#测试代码" class="header-anchor">#</a> 测试代码</h2> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>////将函数模板显示实例化以使用函数指针
template void mergeSort&lt;vector&lt;int&gt; &amp;&gt;(vector&lt;int&gt; &amp;, int, int);
template void quickSort&lt;vector&lt;int&gt; &amp;&gt;(vector&lt;int&gt; &amp;, int, int);
template void insertSort&lt;vector&lt;int&gt; &amp;&gt;(vector&lt;int&gt; &amp;);
template void binaryInsertSort&lt;vector&lt;int&gt; &amp;&gt;(vector&lt;int&gt; &amp;);
template void shellSort&lt;vector&lt;int&gt; &amp;&gt;(vector&lt;int&gt; &amp;);
template void BubbleSort&lt;vector&lt;int&gt; &amp;&gt;(vector&lt;int&gt; &amp;);
template void selectSort&lt;vector&lt;int&gt; &amp;&gt;(vector&lt;int&gt; &amp;);
template void heapSort&lt;vector&lt;int&gt; &amp;&gt;(vector&lt;int&gt; &amp;);


int main() {	
	vector&lt;string&gt; names = { &quot;insertSort&quot;,&quot;binaryInsertSort&quot;,&quot;shellSort&quot;,&quot;BubbleSort&quot;,&quot;selectSort&quot;,&quot;heapSort&quot; };
	void(*sortFunctions[])(vector&lt;int&gt; &amp;) = {insertSort, binaryInsertSort ,shellSort,BubbleSort,selectSort,heapSort };
	for (int i = 0; i &lt; names.size(); i++) {
		vector&lt;int&gt; d1 = { 17,78,45,65,53,32,87,9 };
		vector&lt;int&gt; d2 = { 0 };
		vector&lt;int&gt; d3 = {};
		(*(sortFunctions + i))(d1);
		(*(sortFunctions + i))(d2);
		(*(sortFunctions + i))(d3);
		cout &lt;&lt; &quot;d1：&quot;;
		for (auto x : d1)cout &lt;&lt; x &lt;&lt; &quot; &quot;;
		cout &lt;&lt; &quot;   d2：&quot;;
		for (auto x : d2)cout &lt;&lt; x &lt;&lt; &quot; &quot;;
		cout &lt;&lt; &quot;   d3：&quot;;
		for (auto x : d3)cout &lt;&lt; x &lt;&lt; &quot; &quot;;
		cout &lt;&lt; &quot;     |&quot; &lt;&lt; names.at(i) &lt;&lt; endl;

	}
	{
		vector&lt;int&gt; d1 = { 17,78,45,65,53,32,87,9 };
		vector&lt;int&gt; d2 = { 0 };
		vector&lt;int&gt; d3 = {};
		quickSort(d1, 0, (int)d1.size() - 1);
		cout &lt;&lt; &quot;d1：&quot;;
		for (auto x : d1)cout &lt;&lt; x &lt;&lt; &quot; &quot;;
		cout &lt;&lt; &quot;   d2：&quot;;
		for (auto x : d2)cout &lt;&lt; x &lt;&lt; &quot; &quot;;
		cout &lt;&lt; &quot;   d3：&quot;;
		for (auto x : d3)cout &lt;&lt; x &lt;&lt; &quot; &quot;;
		cout &lt;&lt; &quot;     |&quot; &lt;&lt; &quot;quickSort&quot; &lt;&lt; endl;
	}
	vector&lt;int&gt; d1 = { 17,78,45,65,53,32,87,9 };
	vector&lt;int&gt; d2 = { 0 };
	vector&lt;int&gt; d3 = {};
	mergeSort(d1, 0, (int)d1.size() - 1);
	cout &lt;&lt; &quot;d1：&quot;;
	for (auto x : d1)cout &lt;&lt; x &lt;&lt; &quot; &quot;;
	cout &lt;&lt; &quot;   d2：&quot;;
	for (auto x : d2)cout &lt;&lt; x &lt;&lt; &quot; &quot;;
	cout &lt;&lt; &quot;   d3：&quot;;
	for (auto x : d3)cout &lt;&lt; x &lt;&lt; &quot; &quot;;
	cout &lt;&lt; &quot;     |&quot; &lt;&lt; &quot;mergeSort&quot; &lt;&lt; endl;
	return 0;
}
/*输出
d1：17 78 45 65 53 32 87 9    d2：0    d3：     |测试数据
d1：9 17 32 45 53 65 78 87    d2：0    d3：     |mergeSort
d1：9 17 32 45 53 65 78 87    d2：0    d3：     |quickSort
d1：9 17 32 45 53 65 78 87    d2：0    d3：     |insertSort
d1：9 17 32 45 53 65 78 87    d2：0    d3：     |binaryInsertSort
d1：9 17 32 45 53 65 78 87    d2：0    d3：     |shellSort
d1：9 17 32 45 53 65 78 87    d2：0    d3：     |BubbleSort
d1：9 17 32 45 53 65 78 87    d2：0    d3：     |selectSort
d1：9 17 32 45 53 65 78 87    d2：0    d3：     |heapSort
*/
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/Algorithm/61~67.html" class="prev">
        剑指Offer-61~67
      </a></span> <span class="next"><a href="/docs/DataStruct/BinaryTreeSearch.html">
        单链表插入删除
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.01c57ae1.js" defer></script><script src="/docs/assets/js/2.6ead0304.js" defer></script><script src="/docs/assets/js/12.b0234b2e.js" defer></script>
  </body>
</html>
