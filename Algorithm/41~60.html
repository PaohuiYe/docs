<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VuePress</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/docs/assets/css/0.styles.5037e10c.css" as="style"><link rel="preload" href="/docs/assets/js/app.01c57ae1.js" as="script"><link rel="preload" href="/docs/assets/js/2.6ead0304.js" as="script"><link rel="preload" href="/docs/assets/js/9.2764f422.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.da0c92a5.js"><link rel="prefetch" href="/docs/assets/js/11.78ba5273.js"><link rel="prefetch" href="/docs/assets/js/12.b0234b2e.js"><link rel="prefetch" href="/docs/assets/js/13.852a65b6.js"><link rel="prefetch" href="/docs/assets/js/14.d65ae1a0.js"><link rel="prefetch" href="/docs/assets/js/15.9f39cd23.js"><link rel="prefetch" href="/docs/assets/js/16.d20db39b.js"><link rel="prefetch" href="/docs/assets/js/3.4617ac6d.js"><link rel="prefetch" href="/docs/assets/js/4.5cc5de6c.js"><link rel="prefetch" href="/docs/assets/js/5.c0a17e28.js"><link rel="prefetch" href="/docs/assets/js/6.00b48d75.js"><link rel="prefetch" href="/docs/assets/js/7.bfe91f85.js"><link rel="prefetch" href="/docs/assets/js/8.cfd2dada.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.5037e10c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><img src="/docs/img/head.jpg" alt="" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Support
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language" class="dropdown-title"><span class="title">Language</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language" class="mobile-dropdown-title"><span class="title">Language</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/language/chinese/" class="nav-link">
  Chinese
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Support
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language" class="dropdown-title"><span class="title">Language</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language" class="mobile-dropdown-title"><span class="title">Language</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/language/chinese/" class="nav-link">
  Chinese
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/docs/Algorithm/" class="sidebar-heading clickable router-link-active open"><span>Algorithm</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/Algorithm/1~20.html" class="sidebar-link">剑指Offer-1~20</a></li><li><a href="/docs/Algorithm/21~40.html" class="sidebar-link">剑指Offer-21~40</a></li><li><a href="/docs/Algorithm/41~60.html" aria-current="page" class="active sidebar-link">剑指Offer-41~60</a></li><li><a href="/docs/Algorithm/61~67.html" class="sidebar-link">剑指Offer-61~67</a></li><li><a href="/docs/Algorithm/Sort.html" class="sidebar-link">排序</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/docs/DataStruct/" class="sidebar-heading clickable"><span>DataStruct</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/DataStruct/BinaryTreeSearch.html" class="sidebar-link">单链表插入删除</a></li><li><a href="/docs/DataStruct/SingleList.html" class="sidebar-link">单链表插入删除</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>[TOC]</p> <h1 id="_41、和为s的连续正数序列"><a href="#_41、和为s的连续正数序列" class="header-anchor">#</a> 41、和为S的连续正数序列</h1> <ul><li><p><strong>题目</strong></p> <p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p> <p>输出描述：</p> <blockquote><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p></blockquote></li> <li><p><strong>实现</strong></p> <p>方法一：</p> <p>绿色序列的和为sum</p> <p><img src="D:%5CNotebook%5Cimg%5C1586591009982.png" alt="1586591009982"></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) {
    vector&lt;vector&lt;int&gt; &gt; res;
    int low = 1, high = 2;
    while (low&lt;high )
    {
        int s = (low + high)*(high - low + 1) / 2;
        if (s == sum) {
            vector&lt;int&gt; sq;
            for (int i = low; i &lt;= high; i++) sq.push_back(i);
            res.push_back(sq);
            low++;
        }
        else if (s &lt; sum) 
            high++;
        else
            low++;
    }
    return res;
}	
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>方法二：</p> <p>序列长度n满足<code>(1+n)*n/2&lt;=sum</code>，可得<code>2&lt;=n&lt;sqrt(2\*sum)</code></p> <ul><li><p>n为奇数
因为<code>中间数 = 平均值</code>是个整数，且<code>sum = n * 中间数</code></p> <p>所以sum是n的整数倍，即<code>sum % n = 0</code></p></li> <li><p>n为偶数
因为<code>sum = 平均值 * n = (中间数 + 0.5) * n = 中间数 * n + 0.5 * n</code>
所以<code>sum % n = 0.5 * n</code></p></li></ul> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) {
    vector&lt;vector&lt;int&gt; &gt; res;
    for (int n = (int)sqrt(2 * sum); n &gt;=2 ; n--) {
        //满足和为sum的奇数序列或偶数序列			
        if ((n &amp; 1) == 1 &amp;&amp; sum%n == 0 ||(n &amp; 1) == 0 &amp;&amp; (sum % n) * 2 == n)
        {
            vector&lt;int&gt; sq;
            int low = sum / n - (n - 1) / 2, high = low + n - 1;
            for (int i = low; i &lt;= high; i++) sq.push_back(i);
            res.push_back(sq);
        }						
    }
    return res;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li></ul> <hr> <h1 id="_42、和为s的两个数字"><a href="#_42、和为s的两个数字" class="header-anchor">#</a> 42、和为S的两个数字</h1> <ul><li><p><strong>题目</strong></p> <p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的两个数，小的在前。</p></li> <li><p><strong>实现</strong></p> <p>方法一：</p> <p>两个绿色数字的和为sum，复杂度O(n)</p> <p><img src="D:%5CNotebook%5Cimg%5C1586596464621.png" alt="1586596464621"></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array, int sum) {
	int l = 0, r = array.size() - 1;
	vector&lt;int&gt; res;		
	while (l&lt;r)
	{			
		while (l&lt;r &amp;&amp; array.at(l) + array.at(r) &gt;sum) r--;
		while (l&lt;r &amp;&amp; array.at(l) + array.at(r) &lt;sum) l++;
		if (array.at(l) + array.at(r) == sum) {
			res.push_back(array.at(l));
			res.push_back(array.at(r));
			break;
		}							
	}
	return res;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>方法二：</p> <p>遍历第一个数，折半查找第二个数，复杂度O(nlog~2~n)</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array, int sum) {
    vector&lt;int&gt; res(2);
    int min = sum * sum;
    int find = false;
    for (auto x : array) {
        int key = sum - x;
        //折半查找key
        int l = 0, r = array.size() - 1;
        while (l &lt;= r) {
            int mid = (l + r) / 2;
            if (array.at(mid) == key &amp;&amp; x*key &lt; min) {
                find = true;					
                res.at(0) = x &lt; key ? x : key;
                res.at(1) = x &gt; key ? x : key;
                min = x * key;					
                break;
            }
            else if (array.at(mid) &lt; mid) r = mid - 1;
            else l = mid + 1;
        }			
    }
    return find ? res : vector&lt;int&gt;();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div></li></ul> <hr> <h1 id="_43、循环左移字符串"><a href="#_43、循环左移字符串" class="header-anchor">#</a> 43、循环左移字符串</h1> <ul><li><p><strong>题目</strong></p> <p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移n位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p></li> <li><p><strong>实现</strong></p> <p>方法一：</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>string LeftRotateString(string str, int n) {
	if (str.size() == 0) return &quot;&quot;;
	n = n % str.size();
	return str.substr(n) + str.substr(0, n);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>方法二：</p> <p><code>abcXYZdef abcXYZdef</code></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>string LeftRotateString(string str, int n) {
	if (str.size() == 0) return &quot;&quot;;
	n = n % str.size();
	string s = str + str;
	return s.substr(n, str.size());	
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul> <h1 id="_44、翻转单词顺序列"><a href="#_44、翻转单词顺序列" class="header-anchor">#</a> 44、翻转单词顺序列</h1> <ul><li><p><strong>题目</strong></p> <p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>string ReverseSentence(string str) {				
    int pre = str.size() - 1;//pre指向单词最后一个字母
    string res = &quot;&quot;;
    //从后往前遍历
    for (int i = pre; i &gt;= 0; i--) {
        if (str.at(i) == ' ') {				
            res += str.substr(i + 1, pre - i) + &quot; &quot;;//截取一个单词			
            pre = i - 1;//pre位置更新
        }
    }		
    res += str.substr(0, pre+1);//处理第一个单词
    return res;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></li></ul> <hr> <h1 id="_45、扑克牌顺子"><a href="#_45、扑克牌顺子" class="header-anchor">#</a> 45、扑克牌顺子</h1> <ul><li><p><strong>题目</strong>
LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。</p> <p>现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p></li> <li><p><strong>实现</strong></p> <p>题目意思就是判断一个序列是否是可以是连续的，0可以当做任意数</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>bool IsContinuous(vector&lt;int&gt; numbers) {		
    //找到最小值，最大值，统计0的个数
    int min, max;
    for (auto x : numbers) 
        if (x) min = x;
    max = min;
    int zeroNum = 0;
    for (auto x : numbers) {
        if (x == 0) {
            zeroNum++;
            continue;
        }
        if (x &lt; min) min = x;
        if (x &gt; max) max = x;			
    }
    //判断
    int dif = max - min + 1;
    if (dif &gt; numbers.size()-zeroNum)//差大于非零数字个数，需要用0补充
        return dif == numbers.size();
    else //差小于等于非零个数，需要用0扩充
        return dif + zeroNum == numbers.size();		
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div></li></ul> <hr> <h1 id="_46、孩子们的游戏-圆圈中最后剩下的数"><a href="#_46、孩子们的游戏-圆圈中最后剩下的数" class="header-anchor">#</a> 46、孩子们的游戏(圆圈中最后剩下的数)</h1> <ul><li><p><strong>题目</strong></p> <p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:</p> <p>首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p> <p>如果没有小朋友，请返回-1</p></li> <li><p><strong>实现</strong></p> <p>方法一：数组模拟</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>int LastRemaining_Solution(int n, int m)
{
    if (n == 0) return -1;
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; n; i++) 
        v.push_back(i);
    int i = 0;
    while (v.size() &gt; 1) {
        i = (i + m - 1) % v.size();
        v.erase(v.begin()+i);			
    }
    return v.front();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>方法二：动态规划(<a href="https://blog.nowcoder.net/n/81a858b422804183a1a51dbfd4084ebc" target="_blank" rel="noopener noreferrer">参考链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <p>f(n)表示n个人的时候，能够存活的位置索引。</p> <p>则有</p> <p><code>f(1) = 0</code></p> <p><code>f(n)=(f(n−1,m)+m) % n</code></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>int LastRemaining_Solution(int n, int m)
{
	if (n == 0 || m == 0) return -1;
	int pre = 0;
	for (int i = 2; i &lt;= n; i++) {
		pre = (pre + m) % i;
	}
	return pre;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ul> <hr> <h1 id="_47、求1-2-3-n"><a href="#_47、求1-2-3-n" class="header-anchor">#</a> 47、求1+2+3+...+n</h1> <ul><li><p><strong>题目</strong></p> <p>求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>int Sum_Solution(int n) {
    int res = n;
    res &amp;&amp; (res += Sum_Solution(n - 1));
    return res;
}	
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>等价于</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>int Sum_Solution(int n) {
    if (n == 0) return n;
    return n + Sum_Solution(n - 1);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul> <hr> <h1 id="_48、不用加减乘除做加法"><a href="#_48、不用加减乘除做加法" class="header-anchor">#</a> 48、不用加减乘除做加法</h1> <ul><li><p><strong>题目</strong>
写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p></li> <li><p><strong>实现</strong></p> <p>十进制做 5+7=12</p> <ol><li>相加各位的值，不算进位，得到<code>2</code>。</li> <li>计算进位值，得到<code>1</code>，左移一位得到<code>10</code>，转为计算<code>2 + 10</code>。</li> <li>重复上述两步，直到进位数为0，则第一个数为结果。</li></ol> <p>二进制做 5+7=12：</p> <p>101 + 111</p> <ol><li>相加各位的值，不算进位，二进制每位相加就相当于各位做异或操作，<code>101 ^ 111=010</code>。</li> <li>计算进位值，二进制进位相当于各位做与操作，<code>101 &amp; 111 = 101</code>，再向左移一位得到<code>1010</code>，转为计算<code>010 + 1010</code></li> <li>重复上述两步， 直到进位数为0，则第一个数为结果。</li></ol> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>int Add(int num1, int num2)
{
    while (num2)
    {
        int sum1 = num1 ^ num2;
        int sum2 = (num1 &amp; num2) &lt;&lt; 1;
        num1 = sum1;
        num2 = sum2;
    }
    return num1;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li></ul> <hr> <h1 id="_49、把字符串转换成整数"><a href="#_49、把字符串转换成整数" class="header-anchor">#</a> 49、把字符串转换成整数</h1> <ul><li><p><strong>题目</strong></p> <p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>public:
	int StrToInt(string str) {	
		if (!str.size()) return 0;
		long long int num = 0;	
		for (int i = (str.at(0) == '-' || str.at(0) == '+') ? 1 : 0
			; i &lt; str.size(); i++) {
			if (str.at(i) &gt; '9' || str.at(i) &lt; '0') return 0;			
			num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (str.at(i) &amp; 0xf);							//等价于：num = num * 10 + str.at(i) - 48;
		}
		if (str.at(0) == '-') num = -num;
		return (num &lt;= INT32_MAX &amp;&amp; num &gt;= INT32_MIN) ? num : 0;
	}
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></li></ul> <hr> <h1 id="_50、数组中重复的数字"><a href="#_50、数组中重复的数字" class="header-anchor">#</a> 50、数组中重复的数字</h1> <ul><li><p><strong>题目</strong></p> <p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p></li> <li><p><strong>实现</strong></p> <p>方法一：用一个长度n的数组记录每个数字出现的此时</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>// Parameters:
//        numbers:     an array of integers
//        length:      the length of array numbers
//        duplication: (Output) the duplicated number in the array number
// Return value:       true if the input is valid, and there are some duplications in the array number
//                     otherwise false
bool duplicate(int numbers[], int length, int* duplication) {
    if (!length) return false;
    int *record = new int[length]{ 0 };
    for (int i = 0; i &lt; length; i++) {
        if (++(*(record + numbers[i])) == 2) {
            *duplication = numbers[i];
            delete[] record;
            return true;
        }
    }
    delete[] record;
    return false;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>方法二：使用原数组记录</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>bool duplicate(int numbers[], int length, int* duplication) {
    if (!length) return false;		
    for (int i = 0; i &lt; length; i++) {
        int absCurr = numbers[i] &lt; 0 ? -numbers[i] : numbers[i];
        if (numbers[absCurr] &lt; 0) {
            *duplication = absCurr;
            return true;
        }
        numbers[absCurr] *= -1;
    }		
    return false;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li></ul> <hr> <h1 id="_51、构建乘积数组"><a href="#_51、构建乘积数组" class="header-anchor">#</a> 51、构建乘积数组</h1> <ul><li><p><strong>题目</strong></p> <p>给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>...*A[i-1]<em>A[i+1]</em>...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）</p></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>- 2 3 4 5
1 - 3 4 5
1 2 - 4 5
1 2 3 - 5
1 2 3 4 -

v1: 1   1       2       6       24
v2: 1   5       20      60      120
B : 120 60      40      30      24
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>方法一：</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) {
    if (A.size() &lt;= 1) return vector&lt;int&gt;();
    vector&lt;int&gt; v1 = { 1 };
    vector&lt;int&gt; v2 = v1;
	//计算下三角
    int base = 1;   
    for (int i = 0; i &lt; A.size() - 1; i++) {
        base *= A.at(i);
        v1.push_back(base);
    }
	//计算上三角
    base = 1;
    for (int i = A.size() - 1; i &gt; 0; i--) {
        base *= A.at(i);
        v2.push_back(base);
    }		
	//交叉相乘
    vector&lt;int&gt; B;		
    for (int i = 0; i &lt; A.size(); i++) 
        B.push_back(v1.at(i) * v2.at(A.size() - i - 1));				
    return B;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>方法二：优化方法一</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) {
    if (A.size() &lt;= 1) return vector&lt;int&gt;();
    vector&lt;int&gt; B = { 1 };		
    //计算下三角
    int base = 1;
    for (int i = 0; i &lt; A.size() - 1; i++) {
        base *= A.at(i);
        B.push_back(base);
    }
    //计算上三角同时交叉相乘
    base = 1;
    int j = 0;		
    for (int i = A.size() - 1; i &gt; 0; i--) {
        base *= A.at(i);			
        B.at(i-1) *= base;
    }				
    return B;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div></li></ul> <hr> <h1 id="_52、正则表达式匹配"><a href="#_52、正则表达式匹配" class="header-anchor">#</a> 52、正则表达式匹配</h1> <ul><li><p><strong>题目</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p><strong>KEY</strong></p> <p>首先，考虑特殊情况：</p> <ol><li>两个字符串都为空，返回<code>true</code>；</li> <li><code>str</code>非空，<code>patter</code>空，返回<code>false</code>；</li> <li><code>str</code>空，<code>patter</code>非空，可能匹配成功，因为<code>*</code>之前的元素可以出现0次；</li></ol> <p>然后开始对比<code>str</code>与<code>pattern</code>的第一个字符，有两种可能</p> <ul><li><p>pattern下一个字符不为<code>*</code></p> <p>直接匹配当前字符。</p> <ul><li><p>匹配成功，继续匹配下一个；（注意这里的匹配成功，除了两个字符相同的情况外，还有一种情况，就是<code>pattern</code>的当前字符为<code>.</code>，同时<code>str</code>的当前字符不为<code>\0</code>。）</p></li> <li><p>匹配失败，直接返回false；</p></li></ul></li> <li><p>pattern下一个字符为<code>*</code></p> <p><code>x*</code>可以代表0个或多个。</p> <ul><li>当<code>x*</code>代表0个x时，相当于跳过这个<code>x*</code>，因此<code>str</code>当前字符不变，<code>pattern</code>当前字符后移两位；</li> <li>当<code>x*</code>代表多个x时，<code>str</code>当前字符移向下一个，pattern当前字符不变；</li></ul> <blockquote><p>举例：</p> <ol><li><p><code>str = &quot;aa&quot;，pattern = &quot;a*a&quot;</code>-&gt;<code>str = &quot;a&quot;，pattern = &quot;a*a&quot;</code>-&gt;</p> <p><code>str = &quot;a&quot;，pattern = &quot;a&quot;</code>，返回<code>true</code>；</p></li> <li><p><code>str = &quot;aaa&quot;，pattern = &quot;a*a&quot;</code>-&gt;<code>str = &quot;aa&quot;，pattern = &quot;a*a&quot;</code>，变为1，返回<code>true</code>；</p></li> <li><p><code>str = &quot;aa&quot;，pattern = &quot;a*c*a&quot;</code>-&gt;<code>str = &quot;a&quot;，pattern = &quot;a*c*a&quot;</code>-&gt;</p> <p><code>str = &quot;a&quot;，pattern = &quot;c*a&quot;</code>-&gt;<code>str = &quot;a&quot;，pattern = &quot;a&quot;</code>，返回<code>true</code>；</p></li></ol></blockquote></li></ul></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>bool match(const char* str, const char* pattern)
{
    if (*str == '\0' &amp;&amp; *pattern == '\0')
        return true;
    if (*str != '\0' &amp;&amp; *pattern == '\0')
        return false;
    //if the next character in pattern is not '*'
    if (*(pattern + 1) != '*')
    {
        if (*str == *pattern || (*str != '\0' &amp;&amp; *pattern == '.'))
            return match(str + 1, pattern + 1);
        else
            return false;
    }
    //if the next character is '*'
    else
    {
        if (*str == *pattern || (*str != '\0' &amp;&amp; *pattern == '.'))
            return match(str, pattern + 2) || match(str + 1, pattern);
        else
            return match(str, pattern + 2);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div></li></ul> <hr> <h1 id="_53、表示数值的字符串"><a href="#_53、表示数值的字符串" class="header-anchor">#</a> 53、表示数值的字符串</h1> <ul><li><p><strong>题目</strong></p> <p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。</p></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>bool isNumeric(const char* string)
{
    if (*string == 0) return false;
    bool hasDecimal = false;//有小数点
    bool hasScience = false;//有E
    bool hasSymbol = false;//有+ - 
    bool isFirst = true;//是数字的开头
    while (*string) {
        if (*string == '+' || *string == '-') {
            if (hasSymbol || !isFirst) return false; //已经有过+ -或不在数字开头
            hasSymbol = true;				
        }
        else if (*string == '.') {
            if (hasDecimal) return false; //已经有过小数点					
            hasDecimal = true;
        }
        else if (*string == 'e' || *string == 'E') {
            if (hasScience) return false; //已经有过e E					
            if (*(string + 1) == 0) return false; //e E在结尾		
            if (*(string + 1) == '+' || *(string + 1) == '-') string++;
            hasDecimal = true; //e后面禁止小数
            hasScience = true;				
        }
        else if (*string&lt;'0' || *string&gt;'9') return false;
        isFirst = false;
        string++;
    }
    return true;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div></li></ul> <h1 id="_54、字符流中第一个不重复的字符"><a href="#_54、字符流中第一个不重复的字符" class="header-anchor">#</a> 54、字符流中第一个不重复的字符</h1> <ul><li><p><strong>题目</strong></p> <p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。如果当前字符流没有存在出现一次的字符，返回#字符。</p> <p>例如字符流为“google&quot;时，输出为&quot;ggg#ll&quot;。</p></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>//Insert one char from stringstream
map&lt;char, int&gt; mp;
string str = &quot;&quot;;
void Insert(char ch)
{
    mp[ch]++;
    str+=ch;
}
//return the first appearence once char in current stringstream
char FirstAppearingOnce()
{
    for (int i = 0; i &lt; str.size(); ++i) 
        if (mp[str[i]] == 1)
            return str[i];
    return '#';
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></li></ul> <h1 id="_55、链表中环的入口结点"><a href="#_55、链表中环的入口结点" class="header-anchor">#</a> 55、链表中环的入口结点</h1> <ul><li><p><strong>题目</strong></p> <p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p></li> <li><p><strong>实现</strong></p> <p>方法一：用map存储每个节点，空间复杂度O(n)</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>ListNode* EntryNodeOfLoop(ListNode* pHead)
{
    map&lt;ListNode*, bool&gt; m;
    while(pHead) {
        if (m[pHead]) return pHead;
        m[pHead] = true;
        pHead = pHead-&gt;next;
    }
    return nullptr;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>方法二：空间复杂度O(1)</p> <p><a href="https://www.nowcoder.com/questionTerminal/253d2c59ec3e4bc68da16833f79a38e4" target="_blank" rel="noopener noreferrer">参考链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>两个结论：</p> <ol><li><p>设置快慢指针，假如有环，他们最后一定相遇。</p></li> <li><p>两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇与环入口。</p> <p>证明：</p> <blockquote><p>设：</p> <p>链表头到环入口长度为--<strong>a</strong></p> <p>环入口到相遇点长度为--<strong>b</strong></p> <p>相遇点到环入口长度为--<strong>c</strong></p> <p><img src="D:%5CNotebook%5Cimg%5C1586849247383.png" alt="1586849247383"></p> <p>则：相遇时
快指针路程=a+(b+c)k+b ，k&gt;=1  其中b+c为环的长度，k为绕环的圈数（k&gt;=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。
慢指针路程=a+b
快指针走的路程是慢指针的两倍，所以：
（a+b）*2=a+(b+c)k+b
化简可得：
a=(k-1)(b+c)+c 这个式子的意思是： 链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度。其中k&gt;=1,所以k-1&gt;=0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。</p></blockquote></li></ol> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>ListNode* EntryNodeOfLoop(ListNode* pHead)
{
    if (!pHead) return nullptr;
    ListNode* pFast = pHead;
    ListNode* pSlow = pHead;
    do {
        if (pFast-&gt;next == nullptr)  return nullptr;
        pFast  = pFast-&gt;next-&gt;next;
        pSlow = pSlow-&gt;next;			
    } while (pFast != pSlow);
    while (pHead !=pSlow)
    {
        pHead = pHead-&gt;next;
        pSlow = pSlow-&gt;next;
    }
    return pHead;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li></ul> <h1 id="_56、删除链表中重复的结点"><a href="#_56、删除链表中重复的结点" class="header-anchor">#</a> 56、删除链表中重复的结点</h1> <ul><li><p><strong>题目</strong></p> <p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>void erase(ListNode *&amp;curr) {//删除curr后一个节点
	ListNode *del = curr-&gt;next;
	curr-&gt;next = del-&gt;next;
	del-&gt;next = nullptr;
	delete del;
}
ListNode* deleteDuplication(ListNode* pHead)
{
	if (!pHead) return nullptr;
	ListNode *pre = new ListNode(-1);//设置虚头节点
	pre-&gt;next = pHead;
	pHead = pre;
	ListNode *curr = pHead-&gt;next;
	while (curr)
	{
		if (curr-&gt;next &amp;&amp; curr-&gt;next-&gt;val == curr-&gt;val) {//当前节点与后一个相同
			while (curr-&gt;next &amp;&amp;curr-&gt;next-&gt;val == curr-&gt;val) //删除后面重复的
				erase(curr);
			erase(pre);//删除当前节点
			curr = pre-&gt;next;
		}
		else {
			pre = curr;
			curr = curr-&gt;next;
		}
	}
	return pHead-&gt;next;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>删除重复节点，保留一个：</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>ListNode* deleteDuplication(ListNode* pHead)
{
    if (!pHead) return nullptr;
    ListNode *curr = pHead;
    while (curr)		
        if (curr-&gt;next &amp;&amp; curr-&gt;next-&gt;val == curr-&gt;val) 
            while (curr-&gt;next &amp;&amp;curr-&gt;next-&gt;val == curr-&gt;val) //删除后面重复的
                erase(curr);		
    else curr = curr-&gt;next;		
    return pHead;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li></ul> <hr> <h1 id="_57、二叉树的下一个结点"><a href="#_57、二叉树的下一个结点" class="header-anchor">#</a> 57、二叉树的下一个结点</h1> <ul><li><p><strong>题目</strong></p> <p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>struct TreeLinkNode {
	int val;
	struct TreeLinkNode *left;
	struct TreeLinkNode *right;
	struct TreeLinkNode *next;
	TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
	}
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p><strong>实现</strong></p> <p>方法一，先找到根结点，然后中序遍历整个树，中间输出</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>TreeLinkNode* GetNext(TreeLinkNode* pNode)
{
    TreeLinkNode *root = pNode;
    while (root-&gt;next) root = root-&gt;next;
    bool find = false;
    stack&lt;TreeLinkNode *&gt; s;
    //中序遍历根节点
    s.push(root);//line：1
    bool isTraceBack = false;//line：2
    while (!s.empty()) {
        TreeLinkNode *curr = s.top();
        //1、有左节点 且 不是回溯 中序遍历左子树
        if (curr-&gt;left &amp;&amp; !isTraceBack) s.push(curr-&gt;left);
        else {//无左节点 或 是回溯到当前节点的
            //2、输出当前节点并在栈中删除该节点
            if (find) return curr;
            if (curr == pNode) find = true;
            cout &lt;&lt; curr-&gt;val;
            s.pop();
            //3、如果存在右节点，中序遍历右子树
            if (curr-&gt;right) {
                s.push(curr-&gt;right);//对应line：1
                isTraceBack = false;//对应line：2
            }
            else//回溯 
                isTraceBack = true;
        }
    }
    return nullptr;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>方法二：考虑各种情况</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>TreeLinkNode* GetNext(TreeLinkNode* pNode)
{
    if (pNode-&gt;right) {//pNode有右节点
        auto n = pNode-&gt;right;
        while (n-&gt;left) n = n-&gt;left;
        return n;
    }
    else {//pNode没有右节点
        auto parent = pNode-&gt;next;
        if (!parent) return nullptr;
        else if (parent-&gt;left == pNode) return parent;//pNode是左节点						
        else {//pNode右节点
            //向上遍历，直到当前节点是其父节点的左结点，返回父节点
            while (pNode-&gt;next) {
                if (pNode-&gt;next-&gt;left == pNode) return pNode-&gt;next;
                pNode = pNode-&gt;next;
            }
            return nullptr;
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div></li></ul> <hr> <h1 id="_58、对称的二叉树"><a href="#_58、对称的二叉树" class="header-anchor">#</a> 58、对称的二叉树</h1> <ul><li><p><strong>题目</strong></p> <p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p></li> <li><p><strong>实现</strong></p> <p>方法一：BFS</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>bool isSymmetrical(TreeNode* pRoot)
{
    if (!pRoot) return true;
    else if (!pRoot-&gt;left &amp;&amp; !pRoot-&gt;right) return true;
    else if (!pRoot-&gt;left||!pRoot-&gt;right) return false;		
    vector&lt;bool&gt; v1;
    vector&lt;bool&gt; v2;
    queue&lt;TreeNode*&gt; q;
    //把左右子树的一对数看成一个整体出队入队
    q.push(pRoot-&gt;left);
    q.push(pRoot-&gt;right);
    while (!q.empty()) {
        auto l = q.front(); q.pop();			
        auto r = q.front(); q.pop();	

        if (l-&gt;left) {//左-&gt;左
            q.push(l-&gt;left); v1.push_back(1);
        }
        if (r-&gt;right) {//右-&gt;右
            q.push(r-&gt;right);  v2.push_back(0);
        }			
        if (r-&gt;left) {//左-&gt;右
            q.push(r-&gt;left); v2.push_back(1);
        }
        if (l-&gt;right) {//右-&gt;左
            q.push(l-&gt;right); v1.push_back(0);
        }
        if (l-&gt;val != r-&gt;val)//判断值是否相同
            return false;
        if (v1.size()!=v2.size())//判断节点数目是否相同
            return false;
    }		
    if (!equal(v1,v2)) //判断结构是否是镜像
        return false;
    return true;
}
bool equal(vector&lt;bool&gt; v1, vector&lt;bool&gt; v2) {
    for (int i = 0; i &lt; v1.size(); i++) {
        if (v1.at(i) + v2.at(i) != 1)//1对应0  0对应1
            return false;			
    }
    return true;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p>方法二：递归</p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>bool isSymmetrical(TreeNode* pRoot)
{
    if (!pRoot) return true;
    return isSymmetrical(pRoot-&gt;left, pRoot-&gt;right);
}
bool isSymmetrical(TreeNode* left, TreeNode* right) {
    if (!left &amp;&amp; !right) return true;
    if (!left || !right) return false;
    return left-&gt;val == right-&gt;val //左右节点值相等
        &amp;&amp; isSymmetrical(left-&gt;left, right-&gt;right) //对称的子树也是镜像
        &amp;&amp; isSymmetrical(left-&gt;right, right-&gt;left);//对称的子树也是镜像
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li></ul> <hr> <h1 id="_59、按之字形顺序打印二叉树"><a href="#_59、按之字形顺序打印二叉树" class="header-anchor">#</a> 59、按之字形顺序打印二叉树</h1> <ul><li><p><strong>题目</strong></p> <p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) {
	vector&lt;vector&lt;int&gt; &gt; res;
	if (!pRoot) return res;
	list&lt;TreeNode*&gt; q;
	bool flag = true;

	q.push_back(pRoot);
	while (!q.empty()) {
		int size = q.size();
		vector&lt;int&gt; v;
		while (size--) {
			if (flag) {//正向
				TreeNode* curr = q.back();
				q.pop_back();
				cout &lt;&lt; curr-&gt;val &lt;&lt; &quot; &quot;;
				v.push_back(curr-&gt;val);
				if (curr-&gt;left) q.push_front(curr-&gt;left);
				if (curr-&gt;right) q.push_front(curr-&gt;right);
			}
			else {//反向
				TreeNode* curr = q.front();
				q.pop_front();
				cout &lt;&lt; curr-&gt;val &lt;&lt; &quot; &quot;;
				v.push_back(curr-&gt;val);
				if (curr-&gt;right) q.push_back(curr-&gt;right);
				if (curr-&gt;left) q.push_back(curr-&gt;left);
			}
		}
		res.push_back(v);
		cout &lt;&lt; endl;
		flag = !flag;
	}
	return res;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div></li></ul> <hr> <h1 id="_60、把二叉树打印成多行"><a href="#_60、把二叉树打印成多行" class="header-anchor">#</a> 60、把二叉树打印成多行</h1> <ul><li><p><strong>题目</strong></p> <p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p></li> <li><p><strong>实现</strong></p> <div class="language-c++ line-numbers-mode"><pre class="language-text"><code>vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) {
    vector&lt;vector&lt;int&gt; &gt; res;
    if (!pRoot) return res;
    queue&lt;TreeNode*&gt; q;
    q.push(pRoot);
    while (!q.empty()) {
        int size = q.size();
        vector&lt;int&gt; v;
        while (size--) {
            TreeNode* curr = q.front();
            q.pop();
            v.push_back(curr-&gt;val);
            if (curr-&gt;left) q.push(curr-&gt;left);
            if (curr-&gt;right) q.push(curr-&gt;right);
        }
        res.push_back(v);

    }
    return res;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/Algorithm/21~40.html" class="prev">
        剑指Offer-21~40
      </a></span> <span class="next"><a href="/docs/Algorithm/61~67.html">
        剑指Offer-61~67
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.01c57ae1.js" defer></script><script src="/docs/assets/js/2.6ead0304.js" defer></script><script src="/docs/assets/js/9.2764f422.js" defer></script>
  </body>
</html>
